import type {
  EntityMetadata,
  ImportMetadata,
  PropertyMetadata,
  RelationshipPropertyMetadata,
} from './types';

const generateImports = (
  entity: EntityMetadata,
  imports: ImportMetadata[],
  relationships: RelationshipPropertyMetadata[],
): string => {
  const lines: string[] = [];

  // Import the entity type
  const entityPath = entity.entityImportPath ?? `./${entity.resourceType}.entity`;
  lines.push(`import type { ${entity.name}Entity } from '${entityPath}';`);

  for (const imp of imports) {
    const typePrefix = imp.isTypeOnly ? 'type ' : '';
    lines.push(`import ${typePrefix}{ ${imp.name} } from '${imp.moduleSpecifier}';`);
  }

  const relatedTypes = new Set(relationships.map((r) => `${r.relationshipName}Resource`));
  if (relatedTypes.size > 0) {
    lines.push(`import type { ${[...relatedTypes].join(', ')} } from './index';`);
  }

  return lines.join('\n') + '\n\n';
};

const generatePropertyLine = (prop: PropertyMetadata): string => {
  const optional = prop.isOptional ? '?' : '';
  return `  ${prop.name}${optional}: ${prop.type};`;
};

const generateAttributesInterface = (entity: EntityMetadata): string => {
  const lines = entity.attributes.map(generatePropertyLine);
  return `export interface ${entity.name}Attributes {\n${lines.join('\n')}\n}`;
};

const generateRelationshipDataType = (rel: RelationshipPropertyMetadata): string =>
  rel.isArray
    ? `{ id: string; type: '${rel.resourceType}' }[]`
    : `{ id: string; type: '${rel.resourceType}' }`;

const generateRelationshipType = (rel: RelationshipPropertyMetadata): string =>
  `  ${rel.name}: { data: ${generateRelationshipDataType(rel)} };`;

const generateRelationshipsInterface = (entity: EntityMetadata): string => {
  if (entity.relationships.length === 0) return '';

  const lines = entity.relationships.map(generateRelationshipType);
  return `export interface ${entity.name}Relationships {\n${lines.join('\n')}\n}\n\n`;
};

const generateResourceInterface = (entity: EntityMetadata): string => {
  const hasRelationships = entity.relationships.length > 0;
  const relationshipsProperty = hasRelationships
    ? `\n  relationships: ${entity.name}Relationships;`
    : '';

  return `export interface ${entity.name}Resource {
  id: string;
  type: '${entity.resourceType}';
  attributes: ${entity.name}Attributes;${relationshipsProperty}
}`;
};

const generateAttributeAssignments = (
  entity: EntityMetadata,
  paramName: string,
): string => {
  const assignments = entity.attributes.map((a) => `    ${a.name}: ${paramName}.${a.name},`);
  return assignments.join('\n');
};

const generateRelationshipAssignment = (
  rel: RelationshipPropertyMetadata,
  paramName: string,
): string => {
  if (rel.isArray) {
    return `    ${rel.name}: { data: ${paramName}.${rel.name}?.map((r) => ({ id: r.id, type: '${rel.resourceType}' as const })) ?? [] },`;
  }
  return `    ${rel.name}: { data: ${paramName}.${rel.name} ? { id: ${paramName}.${rel.name}.id, type: '${rel.resourceType}' as const } : null! },`;
};

const generateRelationshipAssignments = (
  entity: EntityMetadata,
  paramName: string,
): string => {
  if (entity.relationships.length === 0) return '';

  const assignments = entity.relationships.map((r) =>
    generateRelationshipAssignment(r, paramName)
  );
  return `\n  relationships: {\n${assignments.join('\n')}\n  },`;
};

const generateMapperFunction = (entity: EntityMetadata): string => {
  const paramName = entity.resourceType.replace(/-([a-z])/g, (_, c) => c.toUpperCase());
  const attributeAssignments = generateAttributeAssignments(entity, paramName);
  const relationshipAssignments = generateRelationshipAssignments(entity, paramName);

  return `export const as${entity.name}Resource = (${paramName}: ${entity.name}Entity): ${entity.name}Resource => ({
  id: ${paramName}.id,
  type: '${entity.resourceType}',
  attributes: {
${attributeAssignments}
  },${relationshipAssignments}
});`;
};

export const generateDtoFile = (entity: EntityMetadata): string => {
  const header = '// Auto-generated by json-api-codegen\n// Do not edit manually\n\n';
  const imports = generateImports(entity, entity.imports, entity.relationships);
  const attributesInterface = generateAttributesInterface(entity);
  const relationshipsInterface = generateRelationshipsInterface(entity);
  const resourceInterface = generateResourceInterface(entity);
  const mapper = generateMapperFunction(entity);

  return `${header}${imports}${attributesInterface}\n\n${relationshipsInterface}${resourceInterface}\n\n${mapper}\n`;
};

export const generateIndexFile = (entities: EntityMetadata[]): string => {
  const header = '// Auto-generated by json-api-codegen\n// Do not edit manually\n\n';
  const exports = entities.map((e) => {
    const kebabName = e.resourceType;
    return `export * from './${kebabName}.resource';`;
  });

  return `${header}${exports.join('\n')}\n`;
};
