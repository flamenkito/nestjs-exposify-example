import * as fs from 'fs';
import * as path from 'path';
import { Parser } from './parser';
import { GeneratorOptions, ServiceMetadata, TypeMetadata } from './types';
import { jsonRpcClientTemplate } from './templates/json-rpc-client';

const FILE_HEADER = `/**
 * This file is auto-generated by @example/client-gen.
 * Do not edit manually.
 */

`;

export class Generator {
  private parser: Parser;

  constructor() {
    this.parser = new Parser();
  }

  generate(options: GeneratorOptions): void {
    const { inputs, output, endpoint } = options;

    // Parse source files
    console.log(`Parsing source files from: ${inputs.join(', ')}`);
    const result = this.parser.parse(inputs);

    console.log(`Found ${result.services.length} services, ${result.types.length} types`);

    // Create output directories
    const servicesDir = path.join(output, 'services');
    const modelsDir = path.join(output, 'models');

    fs.mkdirSync(servicesDir, { recursive: true });
    fs.mkdirSync(modelsDir, { recursive: true });

    // Generate JSON-RPC client
    const clientCode = jsonRpcClientTemplate(endpoint);
    fs.writeFileSync(path.join(output, 'json-rpc.client.ts'), FILE_HEADER + clientCode);
    console.log('Generated: json-rpc.client.ts');

    // Generate services
    const serviceNames: string[] = [];
    for (const service of result.services) {
      const fileName = this.toKebabCase(service.className) + '.service.ts';
      const filePath = path.join(servicesDir, fileName);
      const code = this.generateService(service);
      fs.writeFileSync(filePath, FILE_HEADER + code);
      serviceNames.push(service.className);
      console.log(`Generated: services/${fileName}`);
    }

    // Generate models
    const modelNames: string[] = [];
    for (const type of result.types) {
      const fileName = this.toKebabCase(type.name) + '.ts';
      const filePath = path.join(modelsDir, fileName);
      const code = this.generateModel(type, result.types);
      fs.writeFileSync(filePath, FILE_HEADER + code);
      modelNames.push(type.name);
      console.log(`Generated: models/${fileName}`);
    }

    // Generate models index
    const modelsIndex = this.generateModelsIndex(result.types);
    fs.writeFileSync(path.join(modelsDir, 'index.ts'), FILE_HEADER + modelsIndex);
    console.log('Generated: models/index.ts');

    // Generate services index
    const servicesIndex = this.generateServicesIndex(result.services);
    fs.writeFileSync(path.join(servicesDir, 'index.ts'), FILE_HEADER + servicesIndex);
    console.log('Generated: services/index.ts');

    // Generate main index
    const mainIndex = this.generateMainIndex();
    fs.writeFileSync(path.join(output, 'index.ts'), FILE_HEADER + mainIndex);
    console.log('Generated: index.ts');

    console.log(`\nGeneration complete! Output: ${output}`);
  }

  private generateService(service: ServiceMetadata): string {
    const imports = this.collectServiceImports(service);
    const methods = service.methods.map((m) => this.generateMethod(service.className, m)).join('\n\n');

    return `import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { JsonRpcClient } from '../json-rpc.client';
${imports}

@Injectable({ providedIn: 'root' })
export class ${service.className} {
  constructor(private rpc: JsonRpcClient) {}

${methods}
}
`;
  }

  private collectServiceImports(service: ServiceMetadata): string {
    const types = new Set<string>();

    for (const method of service.methods) {
      // Collect parameter types
      for (const param of method.parameters) {
        this.extractTypeNames(param.type, types);
      }
      // Collect return type
      this.extractTypeNames(method.returnType, types);
    }

    // Filter out primitives
    const primitives = ['string', 'number', 'boolean', 'void', 'null', 'undefined', 'any', 'unknown'];
    const importTypes = Array.from(types).filter((t) => !primitives.includes(t.toLowerCase()));

    if (importTypes.length === 0) return '';

    return `import { ${importTypes.join(', ')} } from '../models';`;
  }

  private extractTypeNames(typeStr: string, types: Set<string>): void {
    // Extract type names from complex types like UserDto[], Promise<UserDto>, etc.
    const matches = typeStr.match(/[A-Z][a-zA-Z0-9]*/g);
    if (matches) {
      for (const match of matches) {
        if (!['Promise', 'Observable', 'Array'].includes(match)) {
          types.add(match);
        }
      }
    }
  }

  private generateMethod(className: string, method: { name: string; parameters: { name: string; type: string }[]; returnType: string }): string {
    const params = method.parameters.map((p) => `${p.name}: ${p.type}`).join(', ');
    const rpcMethod = `${className}.${method.name}`;

    let rpcParams = '';
    if (method.parameters.length === 1) {
      rpcParams = `, ${method.parameters[0].name}`;
    } else if (method.parameters.length > 1) {
      const paramObj = method.parameters.map((p) => p.name).join(', ');
      rpcParams = `, { ${paramObj} }`;
    }

    return `  ${method.name}(${params}): Observable<${method.returnType}> {
    return this.rpc.call<${method.returnType}>('${rpcMethod}'${rpcParams});
  }`;
  }

  private generateModel(type: TypeMetadata, allTypes: TypeMetadata[]): string {
    let code: string;

    if (type.kind === 'class') {
      // Convert class to interface (strip decorators)
      code = this.classToInterface(type.sourceCode, type.name);
    } else {
      // For interfaces, enums, type aliases - use as is but clean imports
      code = this.cleanImports(type.sourceCode);
    }

    // Find referenced types and add imports
    const imports = this.findModelImports(code, type.name, allTypes);
    if (imports) {
      return imports + '\n' + code;
    }

    return code;
  }

  private findModelImports(code: string, currentTypeName: string, allTypes: TypeMetadata[]): string {
    const referencedTypes: string[] = [];

    for (const t of allTypes) {
      if (t.name === currentTypeName) continue;

      // Check if this type is referenced in the code (as a type, not just in text)
      const typePattern = new RegExp(`\\b${t.name}\\b(?:<|\\s|;|\\)|\\]|,)`, 'g');
      if (typePattern.test(code)) {
        referencedTypes.push(t.name);
      }
    }

    if (referencedTypes.length === 0) return '';

    return referencedTypes
      .map((t) => `import { ${t} } from './${this.toKebabCase(t)}';`)
      .join('\n');
  }

  private classToInterface(code: string, name: string): string {
    const lines = code.split('\n');
    const result: string[] = [];
    let inClass = false;
    let braceCount = 0;

    for (const line of lines) {
      const trimmed = line.trim();

      // Skip decorators
      if (trimmed.startsWith('@')) continue;

      // Convert class declaration to interface
      if (trimmed.includes(`class ${name}`)) {
        result.push(`export interface ${name} {`);
        inClass = true;
        braceCount = 1;
        continue;
      }

      if (inClass) {
        // Count braces
        braceCount += (line.match(/{/g) || []).length;
        braceCount -= (line.match(/}/g) || []).length;

        // Skip constructor and methods (lines with parentheses that aren't property declarations)
        if (trimmed.includes('constructor') || (trimmed.includes('(') && !trimmed.includes(':'))) {
          continue;
        }

        // Keep property declarations
        if (trimmed && !trimmed.startsWith('//')) {
          // Clean up property: remove access modifiers, readonly is fine
          const cleanedLine = line
            .replace(/\bprivate\s+/g, '')
            .replace(/\bpublic\s+/g, '')
            .replace(/\bprotected\s+/g, '');
          result.push(cleanedLine);
        }

        if (braceCount === 0) {
          inClass = false;
        }
      } else {
        result.push(line);
      }
    }

    return result.join('\n');
  }

  private cleanImports(code: string): string {
    // Remove class-validator and other decorator imports
    return code
      .replace(/import\s*{[^}]*}\s*from\s*['"]class-validator['"];?\n?/g, '')
      .replace(/import\s*{[^}]*}\s*from\s*['"]class-transformer['"];?\n?/g, '')
      .replace(/@\w+\([^)]*\)\n?/g, ''); // Remove decorator usage
  }

  private generateModelsIndex(types: TypeMetadata[]): string {
    const exports = types
      .map((t) => `export * from './${this.toKebabCase(t.name)}';`)
      .join('\n');

    return exports || '// No models generated\n';
  }

  private generateServicesIndex(services: ServiceMetadata[]): string {
    const exports = services
      .map((s) => `export * from './${this.toKebabCase(s.className)}.service';`)
      .join('\n');

    return exports || '// No services generated\n';
  }

  private generateMainIndex(): string {
    return `export * from './json-rpc.client';
export * from './services';
export * from './models';
`;
  }

  private toKebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
      .toLowerCase();
  }
}
